## Driller

Driller is an implementation of the [driller paper](https://www.cs.ucsb.edu/~vigna/publications/2016_NDSS_Driller.pdf). This implementation was built on top of AFL with angr being used as a symbolic tracer.

Driller selectively traces inputs generated by AFL when AFL stops reporting any paths as 'favorites'.

Driller will take all untraced paths which exist in AFL's queue and look for basic block transitions AFL failed to find satisfying inputs for.

Driller will then use angr to synthesize inputs for these basic block transitions and present it to AFL for syncing.

From here, AFL can determine if any paths generated by Driller are interesting, it will then go ahead and mutate these as normal in an attempt to find more paths.

### The "Stuck" heuristic

Driller's symbolic execution component is invoked when AFL is 'stuck'.
In this implementation, AFL's progress is determined by its 'pending\_favs' attribute which can found in the fuzzer\_stats file.
When this attribute reaches 0, Driller is invoked. Other heuristics could also be used, and it's infact likely that better heuristics exist.

### Use in the Cyber Grand Challenge

This same implementation of Driller was used team Shellphish in DARPA's Cyber Grand Challenge (CGC) to aid in the discovery of exploitable bugs.
To see how Driller's invokation was scheduled for the CGC you can look at the Mechanical Phish's scheduler component 'meister'.

### Current State and Caveats

The code currently supports three modes of operation:

+ A script that facilitates AFL and driller on one machine (over many cores if needed): https://github.com/shellphish/fuzzer/blob/master/shellphuzz
+ A monitor process watches over the fuzzer\_stats file to determine when Driller should be invoked. When Driller looks like it could be useful, the monitor process schedules 'jobs' to work over all the inputs AFL has discovered / deemed interesting.
+ Celery tasks are assigned over a fleet of machines, some number of these tasks are assigned to fuzzing, some are assigned to drilling. Fuzzer tasks monitors the stats file, and invokes driller tasks when Driller looks like it could be useful. Redis is used to sync testcases to the filesystem of the fuzzer.

Driller was built and developed for DECREE binaries.
While some support for other formats should work out-of-the-box, expect `TracerMisfollowError`s to occur when unsupported or incorrectly implemented simprocedures are hit.

# Install:

## cd to parent dir

```bash
cd ../

sudo apt install python3.7 python3.7-dev python3-venv python3.7-venv

python3.7 -m venv hz_driller_venv

source hz_driller_venv/bin/activate
```


so hz_dirller_venv is python3.7 env.

## cd to dirller dir

`sudo apt-get install build-essential gcc-multilib libtool automake autoconf bison debootstrap debian-archive-keyring libtool-bin python3-dev libffi-dev`

Successfully built shellphish-afl
Installing collected packages: shellphish-afl, tqdm, fuzzer
Running setup.py install for fuzzer: started
Running setup.py install for fuzzer: finished with status 'done'
Successfully installed fuzzer-1.1 shellphish-afl-1.2.2 tqdm-4.59.0


原文链接：https://blog.csdn.net/Chen_zju/article/details/84575572

```bash
cd driller
python setup.py install
pip install -r requirements.txt
```


`git下载依赖项失败。 fatal: unable to access 'https://github.com/angr/tracer.git/': gnutls_handshake() failed: The TLS connection was non-properly terminated.`

将 https -> http: git+https://github.com/shellphish/fuzzer.git#egg=fuzzer 改成 git+http://github.com/shellphish/fuzzer.git#egg=fuzzer


error: invalid command 'bdist_wheel'

https://stackoverflow.com/questions/34819221/why-is-python-setup-py-saying-invalid-command-bdist-wheel-on-travis-ci

```
sudo apt-get install gcc libpq-dev -y
sudo apt-get install python-dev  python-pip -y
sudo apt-get install python3-dev python3-pip python3-venv python3-wheel -y
pip3 install wheel
```

https://stackoverflow.com/questions/11041299/python-h-no-such-file-or-directory

```
sudo apt-get install python3.7-dev
```



libtool not found

https://blog.csdn.net/qq_38081870/article/details/104380070

` sudo apt-get install libtool`

`sudo apt-get install libtool-bin`


```
sudo apt install automake  
sudo apt install flex bison
sudo apt-get install libglib2.0-dev

```

```
angr.exploration_techniques.tracer.TracerDesyncError: Oops! angr did not follow the trace 
ans ：

I made a mistake! my binary was a linux compilation from CGC source code. I used from a CGC binary (that compile on DECREE) and my problem was solved.
https://github.com/angr/angr/issues/1609#issuecomment-782581545
```

# Example

Here is an example of using driller to find new testcases based off the trace of a single testcase.

```python
import driller

d = driller.Driller("./CADET_00001",  # path to the target binary
                    "racecar", # initial testcase
                    "\xff" * 65535, # AFL bitmap with no discovered transitions
                   )

new_inputs = d.drill()
```

#### Dependencies

+ Mechaphish Fuzzer component
+ Mechaphish Tracer component
